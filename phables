#!/usr/bin/env python3

from collections import defaultdict
from email.policy import default
import logging
import subprocess
import operator
import sys
import time
import matplotlib.pyplot as plt

import click
import networkx as nx
import numpy as np
from igraph import *
from tqdm import tqdm

from phables_utils import (component_utils, edge_graph_utils, edge_utils,
                             gene_utils)
from phables_utils.genome_utils import GenomeComponent, GenomePath
from phables_utils.CycFlowDec import CycFlowDec

__author__ = "Vijini Mallawaarachchi"
__copyright__ = "Copyright 2022, PhaBles Project"
__license__ = "MIT"
__version__ = "0.1"
__maintainer__ = "Vijini Mallawaarachchi"
__email__ = "vijini.mallawaarachchi@flinders.edu.au"
__status__ = "Development"

MAX_VAL = sys.maxsize
FASTA_LINE_LEN = 60
REPEAT_MIN_LENGTH = 1000

# Sample command
# -------------------------------------------------------------------
# python phables.py  -g /path/to/assembly_graph.gfa
#                    -c /path/to/assembly.fasta
#                    -p /path/to/assembly_info.txt
#                    -o /path/to/output_folder
# -------------------------------------------------------------------


# Setup arguments
# ----------------------------------------------------------------------


@click.command()
@click.option(
    "--graph",
    "-g",
    required=True,
    help="path to the assembly graph file",
    type=click.Path(exists=True),
)
@click.option(
    "--contigs",
    "-c",
    required=True,
    help="path to the contigs file",
    type=click.Path(exists=True),
)
@click.option(
    "--paths",
    "-p",
    required=True,
    help="path to the contig paths file",
    type=click.Path(exists=True),
)
@click.option(
    "--hmmout",
    "-hm",
    required=True,
    help="path to the contig .hmmout file",
    type=click.Path(exists=True),
)
@click.option(
    "--phrogs",
    "-ph",
    required=True,
    help="path to the contig phrog annotations file",
    type=click.Path(exists=True),
)
@click.option(
    "--coverage",
    "-cov",
    required=True,
    help="path to the coverage file",
    type=click.Path(exists=True),
)
@click.option(
    "--minlength",
    "-ml",
    default=2000,
    required=False,
    help="minimum length of circular contigs to consider",
    type=int,
)
@click.option(
    "--mincov",
    "-mcov",
    default=10,
    required=False,
    help="minimum coverage of paths to output",
    type=int,
)
@click.option(
    "--compcount",
    "-cc",
    default=500,
    required=False,
    help="maximum contig count to consider a component",
    type=int,
)
@click.option(
    "--mgfrac",
    "-mgf",
    default=0.2,
    required=False,
    help="length threshold to consider single copy marker genes",
    type=float,
)
@click.option(
    "--alignscore",
    "-as",
    default=90,
    required=False,
    help="minimum alignment score (%) for phrog annotations",
    type=float,
)
@click.option(
    "--seqidentity",
    "-si",
    default=0.3,
    required=False,
    help="minimum sequence identity for phrog annotations",
    type=float,
)
@click.option(
    "--pathlendif",
    "-pld",
    default=5000,
    required=False,
    help="path length difference threshold",
    type=int,
)
@click.option(
    "--output",
    "-o",
    required=True,
    help="path to the output folder",
    type=click.Path(exists=True),
)
def main(
    graph,
    contigs,
    paths,
    hmmout,
    phrogs,
    coverage,
    minlength,
    mincov,
    compcount,
    mgfrac,
    alignscore,
    seqidentity,
    pathlendif,
    output,
):

    """PhaBles: Resolve bacteriophage genomes from phage bubbles in metagenomic data."""

    # Setup logger
    # ----------------------------------------------------------------------

    logger = logging.getLogger("phables 0.1")
    logger.setLevel(logging.DEBUG)
    logging.captureWarnings(True)
    formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
    consoleHeader = logging.StreamHandler()
    consoleHeader.setFormatter(formatter)
    consoleHeader.setLevel(logging.INFO)
    logger.addHandler(consoleHeader)

    # Setup output path for log file
    fileHandler = logging.FileHandler(f"{output}/phables.log")
    fileHandler.setLevel(logging.DEBUG)
    fileHandler.setFormatter(formatter)
    logger.addHandler(fileHandler)

    logger.info(
        "Welcome to PhaBles: Resolve bacteriophage genomes from phage bubbles in metagenomic data."
    )

    logger.info(f"Input arguments: ")
    logger.info(f"Assembly graph file: {graph}")
    logger.info(f"Contigs file: {contigs}")
    logger.info(f"Contig paths file: {paths}")
    logger.info(f"Contig .hmmout file: {hmmout}")
    logger.info(f"Contig phrog annotations file: {phrogs}")
    logger.info(f"Contig coverage file: {coverage}")
    logger.info(f"Minimum length of contigs to consider: {minlength}")
    logger.info(f"Minimum coverage of paths to output: {mincov}")
    logger.info(f"minimum contig count to consider a component: {compcount}")
    logger.info(f"Length threshold to consider single copy marker genes: {mgfrac}")
    logger.info(f"Minimum alignment score (%) for phrog annotations: {alignscore}")
    logger.info(f"Minimum sequence identity for phrog annotations: {seqidentity}")
    logger.info(f"Path length difference threshold: {pathlendif}")
    logger.info(f"Output folder: {output}")

    start_time = time.time()

    # Get assembly graph
    # ----------------------------------------------------------------------
    (
        assembly_graph,
        edge_list,
        oriented_links,
        contig_names,
        contig_names_rev,
        graph_contigs,
        edge_depths,
        self_looped_nodes,
        edges_lengths,
    ) = edge_graph_utils.build_assembly_graph(graph)

    logger.info(
        f"Total number of vertices in the assembly graph: {len(assembly_graph.vs)}"
    )
    logger.info(
        f"Total number of links in the assembly graph: {len(assembly_graph.es)}"
    )

    # Get circular contigs
    # ----------------------------------------------------------------------
    circular = edge_utils.get_circular(paths)

    # Get contigs with bacterial single copy marker genes
    # ----------------------------------------------------------------------
    smg_contigs, contig_smgs = gene_utils.get_smg_contigs(hmmout, mgfrac)

    # Get contigs with PHROGs
    # ----------------------------------------------------------------------
    contig_phrogs = gene_utils.get_phrog_contigs(phrogs, alignscore, seqidentity)

    # Get components with viral bubbles
    # ----------------------------------------------------------------------
    pruned_vs = component_utils.get_components(
        assembly_graph,
        contig_names,
        smg_contigs,
        contig_phrogs,
        circular,
        edges_lengths,
        minlength,
    )
    logger.info(f"Total number of components found: {len(pruned_vs)}")

    # Get contig coverages
    # ----------------------------------------------------------------------

    contig_coverages = {}

    with open(coverage, "r") as myfile:
        for line in myfile.readlines():

            if not line.startswith("Contig"):
                strings = line.strip().split()

                contig_name = strings[0].replace("contig", "edge")

                coverage_sum = sum([float(x) for x in strings[1:]])

                contig_coverages[contig_name] = coverage_sum

    # Resolve genomes
    # ----------------------------------------------------------------------

    resolved_edges = set()

    all_resolved_paths = []

    all_components = []

    cycle_components = set()
    resolved_components = set()
    circular_contigs = set()
    resolved_cyclic = set()

    for my_count in tqdm(pruned_vs, desc="Resolving components"):

        component_time_start = time.time()

        my_genomic_paths = []

        candidate_nodes = pruned_vs[my_count]

        pruned_graph = assembly_graph.subgraph(candidate_nodes)

        # comp_self_looped_nodes = [x for x in pruned_vs[my_count] if contig_names[x] in self_looped_nodes]

        # if 1352 not in candidate_nodes:
        #     continue

        logger.debug(f"my_count: {my_count}")
        

        logger.debug(f"number of contigs: {len(candidate_nodes)}")
        logger.debug(f"{candidate_nodes}")

        in_degree = []
        out_degree = []

        
        if len(candidate_nodes) == 2:

            all_self_looped = True

            for node in candidate_nodes:
                if contig_names[node] not in self_looped_nodes:
                    all_self_looped = False
            
            if all_self_looped:

                cycle_components.add(my_count)

                contig1 = ""
                contig2 = ""

                for edge in pruned_graph.es:
                    source_vertex_id = edge.source
                    target_vertex_id = edge.target

                    if source_vertex_id != target_vertex_id:
                        contig1 = candidate_nodes[source_vertex_id]
                        contig2 = candidate_nodes[target_vertex_id]

                if contig1 != "" and contig2 != "":

                    contig1_name = contig_names[contig1]
                    contig2_name = contig_names[contig2]

                    contig1_orientation = ""
                    contig2_orientation = ""

                    resolved_edges.add(contig1_name)
                    resolved_edges.add(contig2_name)

                    for node in oriented_links[contig1_name]:
                        for edge in oriented_links[contig1_name][node]:
                            contig1_orientation = edge[0]
                            contig2_orientation = edge[1]
                            break

                    path_string = ""

                    if contig1_orientation == "-":
                        path_string += str(graph_contigs[contig1_name].reverse_complement())
                    else:
                        path_string += str(graph_contigs[contig1_name])

                    if contig2_orientation == "-":
                        path_string += str(graph_contigs[contig2_name].reverse_complement())
                    else:
                        path_string += str(graph_contigs[contig2_name])

                    cycle_number = 1

                    genome_path = GenomePath(
                        f"phage_comp_{my_count}_cycle_{cycle_number}",
                        [f"{contig1_name}{contig1_orientation}", f"{contig2_name}{contig2_orientation}"],
                        [contig1_name, contig2_name],
                        path_string,
                        int(min(contig_coverages[contig1_name], contig_coverages[contig2_name])),
                        len(path_string),
                        (path_string.count('G') + path_string.count('C')) / len(path_string) * 100
                    )
                    my_genomic_paths.append(genome_path)
                    resolved_components.add(my_count)


        if len(candidate_nodes) > 2 and len(candidate_nodes) <= compcount:

            # Create Directed Graph
            G_edge=nx.DiGraph()

            my_counter = 0

            node_indices = {}
            node_indices_rev = {}

            cycle_edges = {}

            clean_node_count = 0

            for vertex in pruned_graph.vs["id"]:

                contig_name = contig_names[vertex]

                if contig_name not in self_looped_nodes:
                    clean_node_count += 1

                for node in oriented_links[contig_name]:

                    consider_edge = False

                    if not (contig_name in self_looped_nodes and node in self_looped_nodes):
                        consider_edge = True
                    # elif contig_name in self_looped_nodes and node not in self_looped_nodes and len(str(graph_contigs[contig_name])) > 1000:
                    #     consider_edge = True
                    # elif contig_name not in self_looped_nodes and node in self_looped_nodes and len(str(graph_contigs[node])) > 1000:
                    #     consider_edge = True

                    if consider_edge:

                        cov_1 = MAX_VAL
                        cov_2 = MAX_VAL

                        if contig_name in contig_coverages:
                            cov_1 = contig_coverages[contig_name]
                        if node in contig_coverages:
                            cov_2 = contig_coverages[node]

                        min_cov = min([cov_1, cov_2])

                        for edge in oriented_links[contig_name][node]:
                            cycle_edges[(contig_name+edge[0], node+edge[1])] = min_cov
                        
            # print(node_indices)
            
            for cedge in cycle_edges:
                G_edge.add_edge(cedge[0], cedge[1], weight=cycle_edges[cedge])

            two_comp = sorted(nx.weakly_connected_components(G_edge), key=len)

            if len(two_comp) >= 2:
                G_edge.remove_nodes_from(list(two_comp[0]))

            # Create Directed Graph
            G=nx.DiGraph()

            for u,v,cov in G_edge.edges(data=True):

                # print(u,v,cov)

                if u not in node_indices:
                    node_indices[u] = my_counter
                    node_indices_rev[my_counter] = u
                    my_counter += 1
                if v not in node_indices:
                    node_indices[v] = my_counter
                    node_indices_rev[my_counter] = v
                    my_counter += 1

                G.add_edge(node_indices[u], node_indices[v], weight=cov['weight'])

            nx.draw(G)
            # plt.show()
            
            in_degree = []
            out_degree = []

            for node in list(G.nodes):
                
                if node_indices_rev[node][:-1] not in self_looped_nodes:
                    clean_indegree = len([x for x in G.predecessors(node) if node_indices_rev[x][:-1] not in self_looped_nodes])
                    in_degree.append(clean_indegree)

                    clean_outdegree = len([x for x in G.successors(node) if node_indices_rev[x][:-1] not in self_looped_nodes])
                    out_degree.append(clean_outdegree)

            degrees = in_degree + out_degree

            # print("in/out degrees:", degrees)

            if len(degrees) == 0:
                logger.debug(f"Skipping component as no clean connections were found")
                continue

            clean_max_degree = max(degrees)

            logger.info(f"clean_max_degree: {clean_max_degree}")

            cycle_number = 1

            cycles_iterated = False

            try:
                F = np.zeros([G.number_of_nodes(),G.number_of_nodes()])

                for edge in G.edges.data("weight", default=1):
                    F[edge[1],edge[0]] = edge[2]

                n_points = 50
                init_steps = 10
                step_add = 10
                run_post = 2
                state = 0
                tol = 1E-5

                myCycFlowDec = CycFlowDec(F,state,tol)
                myCycFlowDec.run(init_steps-run_post,run_post)
                steps = [init_steps]
                MREs = [myCycFlowDec.calc_MRE(0)]

                j = 1
                while j < n_points:
                    myCycFlowDec.run(step_add-run_post,run_post)
                    steps.append(steps[-1] + step_add)
                    current_mre = myCycFlowDec.calc_MRE(0)
                    if current_mre > MREs[-1] and current_mre < 1:
                        break
                    MREs.append(current_mre)
                    j += 1

                my_cc = 0

                logger.debug(f"Number of cycles found: {len(myCycFlowDec.cycles.keys())}")
                logger.debug(f"MREs: {MREs}")
                logger.debug(f"Max and min MREs: {max(MREs)} {min(MREs)}")

                if len(myCycFlowDec.cycles.keys()) != 0:
                    cycle_components.add(my_count)

                for cycle in myCycFlowDec.cycles.keys():
                    if myCycFlowDec.cycles[cycle] >= mincov:
                        # logger.info(f"{cycle} {len(cycle)} {myCycFlowDec.cycles[cycle]}")
                        coverage_val = myCycFlowDec.cycles[cycle]
                        cycle = list(cycle)
                        # cycle_0 = cycle[0]
                        # cycle.pop(0)
                        # cycle.append(cycle_0)
                        # cycle.reverse()
                        # print([node_indices_rev[x] for x in cycle], coverage_val)

                        my_cc += 1

                        path_string = ""
                        total_length = 0

                        for node in cycle:
                            contig_name = node_indices_rev[node][:-1]
                            if node_indices_rev[node].endswith("+"):
                                path_string += str(graph_contigs[contig_name])
                            else:
                                path_string += str(graph_contigs[contig_name].reverse_complement())
                            total_length += len(str(graph_contigs[contig_name]))

                        genome_path = GenomePath(
                            f"phage_comp_{my_count}_cycle_{cycle_number}",
                            [node_indices_rev[x] for x in cycle],
                            [node_indices_rev[x][:-1] for x in cycle],
                            path_string,
                            int(coverage_val),
                            total_length,
                            (path_string.count('G') + path_string.count('C')) / len(path_string) * 100
                        )
                        my_genomic_paths.append(genome_path)

                        cycle_number += 1

                logger.debug(f"Number of cycles selected: {cycle_number-1}")

                cycles_iterated = True
            
            except ZeroDivisionError as e:
                logger.debug(f"Encountered {e} Could not find paths")

            if cycles_iterated and len(myCycFlowDec.cycles.keys()) == 0:
                logger.debug(f"No paths were found.")


        elif len(candidate_nodes) == 1:

            contig_name = contig_names[candidate_nodes[0]]

            resolved_edges.add(contig_name)

            path_string = str(graph_contigs[contig_name])

            cycle_number = 1

            genome_path = GenomePath(
                f"phage_comp_{my_count}_cycle_{cycle_number}",
                [contig_names[candidate_nodes[0]]],
                [candidate_nodes[0]],
                path_string,
                int(contig_coverages[contig_name]),
                len(graph_contigs[contig_name]),
                (path_string.count('G') + path_string.count('C')) / len(path_string) * 100
            )
            my_genomic_paths.append(genome_path)
            resolved_components.add(my_count)

            circular_contigs.add(my_count)


        visited_count = {}

        visited_nodes = set()

        my_genomic_paths.sort(key=lambda x: (x.length, x.coverage), reverse=True)

        final_genomic_paths = []

        n_paths = 0

        if len(my_genomic_paths) > 1:

            # Get component stats
            graph_degree = assembly_graph.degree(candidate_nodes)
            # in_degree = assembly_graph.degree(candidate_nodes)
            # out_degree = assembly_graph.degree(candidate_nodes)

            path_lengths = []
            path_coverages = []

            prev_length = my_genomic_paths[0].length

            for genomic_path in my_genomic_paths:

                current_len_dif = abs(prev_length - genomic_path.length)

                if current_len_dif < pathlendif:

                    path_is_subset = False

                    node_count = 0

                    if len(candidate_nodes) <= 5:
                        node_count = 2
                    else:
                        # To avoid bubbles
                        node_count = 3

                    # for final_path in final_genomic_paths:
                    #     if len(set(genomic_path.node_order).difference(set(final_path.node_order).intersection(set(genomic_path.node_order)))) > len(final_path.node_order)/2:
                    #         path_is_subset = True
                    #         break

                    for path_node in genomic_path.node_id_order:
                        if path_node in visited_count:
                            if (
                                visited_count[path_node]
                                >= clean_max_degree
                            ):
                                path_is_subset = True

                    new_nodes = list(set(genomic_path.node_order).difference(visited_nodes))

                    # print("Set diff:", new_nodes)

                    has_new_nodes = False

                    if len(new_nodes) > len(genomic_path.node_order)/clean_max_degree:
                        has_new_nodes = True

                    if len(new_nodes) == 1 and new_nodes[0] not in visited_nodes:
                        has_new_nodes = True

                    if (has_new_nodes or (not path_is_subset)) and genomic_path.length > minlength and len(genomic_path.node_order) >= clean_node_count/clean_max_degree:
                        # prev_length = genomic_path.length

                        logger.debug(f"{genomic_path.id}\t{genomic_path.length}\t{genomic_path.coverage}")
                        logger.debug(f"{genomic_path.node_order}")
                        path_lengths.append(genomic_path.length)
                        path_coverages.append(genomic_path.coverage)
                        final_genomic_paths.append(genomic_path)
                        all_resolved_paths.append(genomic_path)
                        visited_nodes = visited_nodes.union(set(genomic_path.node_order))
                        n_paths += 1

                        for path_node in genomic_path.node_id_order:
                            resolved_edges.add(path_node)

                            if path_node in visited_count:
                                visited_count[path_node] += 1
                            else:
                                visited_count[path_node] = 1

                    else:
                        continue
                        # if n_paths < 10:
                        #     continue
                        # else:
                        #     break

            if len(final_genomic_paths) > 1 and len(in_degree) > 0 and len(out_degree) > 0:

                genome_comp = GenomeComponent(
                    f"phage_comp_{my_count}",
                    len(candidate_nodes),
                    len(final_genomic_paths),
                    max(graph_degree),
                    max(in_degree),
                    max(out_degree),
                    sum(graph_degree) / len(graph_degree),
                    sum(in_degree) / len(in_degree),
                    sum(out_degree) / len(out_degree),
                    pruned_graph.density(loops=False),
                    max(path_lengths),
                    min(path_lengths),
                    max(path_lengths) / min(path_lengths),
                    path_lengths[path_coverages.index(max(path_coverages))],
                    path_lengths[path_coverages.index(min(path_coverages))],
                    path_lengths[path_coverages.index(max(path_coverages))]
                    / path_lengths[path_coverages.index(min(path_coverages))],
                    max(path_coverages),
                    min(path_coverages),
                    max(path_coverages) / min(path_coverages),
                )
                all_components.append(genome_comp)

            if len(final_genomic_paths) > 0:
                resolved_cyclic.add(my_count)
                resolved_components.add(my_count)
                component_elapsed_time = time.time() - component_time_start
                logger.debug(f"Elapsed time to resolve component {my_count} with {len(candidate_nodes)} nodes: {component_elapsed_time} seconds")

        else:
            for genomic_path in my_genomic_paths:
                final_genomic_paths.append(genomic_path)
                all_resolved_paths.append(genomic_path)
                logger.debug(f"{genomic_path.id}\t{genomic_path.length}")
                resolved_components.add(my_count)

        # Write to file

        with open(f"{output}/resolved_paths.fasta", "a+") as myfile:

            for genomic_path in final_genomic_paths:

                myfile.write(f">{genomic_path.id}\n")

                chunks = [
                    genomic_path.path[i : i + FASTA_LINE_LEN]
                    for i in range(0, genomic_path.length, FASTA_LINE_LEN)
                ]

                for chunk in chunks:
                    myfile.write(f"{chunk}\n")

        output_genomes_path = f"{output}/resolved_phages"
        subprocess.run("mkdir -p " + output_genomes_path, shell=True)

        for genomic_path in final_genomic_paths:

            with open(
                f"{output}/resolved_phages/{genomic_path.id}.fasta", "w+"
            ) as myfile:

                myfile.write(f">{genomic_path.id}\n")

                chunks = [
                    genomic_path.path[i : i + FASTA_LINE_LEN]
                    for i in range(0, genomic_path.length, FASTA_LINE_LEN)
                ]

                for chunk in chunks:
                    myfile.write(f"{chunk}\n")

    # resolved_cyclic = len(cycle_components) - (len(resolved_components) - len(circular_contigs))

    logger.info(f"Total number of cyclic components found: {len(cycle_components)}")
    logger.info(f"Total number of cyclic components resolved: {len(resolved_cyclic)}")
    logger.info(f"Circular contigs identified: {len(circular_contigs)}")
    logger.info(f"Total number of cyclic components found including circular contigs: {len(cycle_components) + len(circular_contigs)}")
    logger.info(f"Total number of components resolved: {len(resolved_components)}")
    logger.info(f"Total number of genomes resolved: {len(all_resolved_paths)}")
    logger.info(f"Resolved genomes can be found in {output}/resolved_paths.fasta")

    with open(f"{output}/resolved_edges.fasta", "w+") as myfile:
        for edge in resolved_edges:

            edge_seq = str(graph_contigs[edge])

            myfile.write(">" + edge + "\n")

            chunks = [
                edge_seq[i : i + FASTA_LINE_LEN]
                for i in range(0, len(edge_seq), FASTA_LINE_LEN)
            ]

            for chunk in chunks:
                myfile.write(chunk + "\n")

    # Record path information
    # ----------------------------------------------------------------------

    with open(f"{output}/resolved_genome_info.txt", "w") as myfile:
        myfile.write(f"Path\tCoverage\tLength\tGC content\tNode order\n")
        for genomic_path in all_resolved_paths:
            myfile.write(
                f"{genomic_path.id}\t{genomic_path.coverage}\t{genomic_path.length}\t{genomic_path.gc}\t{genomic_path.node_order}\n"
            )

    logger.info(
        f"Resolved genome information can be found in {output}/resolved_genome_info.txt"
    )

    # Record component information
    # ----------------------------------------------------------------------

    with open(f"{output}/resolved_component_info.txt", "w") as myfile:
        myfile.write(f"Component\t")
        myfile.write(f"Number of nodes\t")
        myfile.write(f"Number of paths\t")
        myfile.write(f"Maximum degree\t")
        myfile.write(f"Maximum in degree\t")
        myfile.write(f"Maximum out degree\t")
        myfile.write(f"Average degree\t")
        myfile.write(f"Average in degree\t")
        myfile.write(f"Average out degree\t")
        myfile.write(f"Density\t")
        myfile.write(f"Maximum path length\t")
        myfile.write(f"Minimum path length\t")
        myfile.write(f"Length ratio (long/short)\t")
        myfile.write(f"Maximum coverage path length\t")
        myfile.write(f"Minimum coverage path length\t")
        myfile.write(f"Length ratio (highest cov/lowest cov)\t")
        myfile.write(f"Maximum coverage\t")
        myfile.write(f"Minimum coverage\t")
        myfile.write(f"Coverage ratio (highest/lowest)\n")

        for component in all_components:
            myfile.write(f"{component.id}\t")
            myfile.write(f"{component.n_nodes}\t")
            myfile.write(f"{component.n_paths}\t")
            myfile.write(f"{component.max_degree}\t")
            myfile.write(f"{component.max_in_degree}\t")
            myfile.write(f"{component.max_out_degree}\t")
            myfile.write(f"{component.avg_degree}\t")
            myfile.write(f"{component.avg_in_degree}\t")
            myfile.write(f"{component.avg_out_degree}\t")
            myfile.write(f"{component.density}\t")
            myfile.write(f"{component.max_path_length}\t")
            myfile.write(f"{component.min_path_length}\t")
            myfile.write(f"{component.min_max_len_ratio}\t")
            myfile.write(f"{component.max_cov_path_length}\t")
            myfile.write(f"{component.min_cov_path_length}\t")
            myfile.write(f"{component.min_max_cov_len_ratio}\t")
            myfile.write(f"{component.max_cov}\t")
            myfile.write(f"{component.min_cov}\t")
            myfile.write(f"{component.min_max_cov_ratio}\n")

    logger.info(
        f"Resolved component information can be found in {output}/resolved_component_info.txt"
    )

    # Get elapsed time
    # ----------------------------------------------------------------------

    # Determine elapsed time
    elapsed_time = time.time() - start_time

    # Print elapsed time for the process
    logger.info("Elapsed time: " + str(elapsed_time) + " seconds")

    # Exit program
    # ----------------------------------------------------------------------

    logger.info("Thank you for using phables!")


if __name__ == "__main__":
    main()

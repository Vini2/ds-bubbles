#!/usr/bin/env python3

import logging
import subprocess
import os
import sys
import time
from collections import defaultdict
import os
import pickle
import pysam
import glob

import click
import networkx as nx
import numpy as np
from igraph import *
from tqdm import tqdm

from phables_utils import (component_utils, edge_graph_utils, edge_utils, gene_utils)
from phables_utils.genome_utils import GenomeComponent, GenomePath
from phables_utils.coverage_utils import get_edge_coverage, get_junction_pe_coverage, get_graph_spanning_reads
from phables_utils.output_utils import write_edges, write_component_info, write_res_genome_info, write_path, write_path_fasta
from phables_utils.FD_Inexact import SolveInstances

__author__ = "Vijini Mallawaarachchi"
__copyright__ = "Copyright 2022, PhaBles Project"
__license__ = "MIT"
__version__ = "0.1"
__maintainer__ = "Vijini Mallawaarachchi"
__email__ = "vijini.mallawaarachchi@flinders.edu.au"
__status__ = "Development"

MAX_VAL = sys.maxsize

# Sample command
# -------------------------------------------------------------------
# python phables.py  -g /path/to/assembly_graph.gfa
#                    -c /path/to/assembly.fasta
#                    -p /path/to/assembly_info.txt
#                    -o /path/to/output_folder
# -------------------------------------------------------------------


# Setup arguments
# ----------------------------------------------------------------------


@click.command()
@click.option(
    "--graph",
    "-g",
    required=True,
    help="path to the assembly graph file",
    type=click.Path(exists=True),
)
@click.option(
    "--contigs",
    "-c",
    required=True,
    help="path to the contigs file",
    type=click.Path(exists=True),
)
@click.option(
    "--paths",
    "-p",
    required=True,
    help="path to the contig paths file",
    type=click.Path(exists=True),
)
@click.option(
    "--hmmout",
    "-hm",
    required=True,
    help="path to the contig .hmmout file",
    type=click.Path(exists=True),
)
@click.option(
    "--phrogs",
    "-ph",
    required=True,
    help="path to the contig phrog annotations file",
    type=click.Path(exists=True),
)
@click.option(
    "--coverage",
    "-cov",
    required=True,
    help="path to the coverage file",
    type=click.Path(exists=True),
)
@click.option(
    "--bampath",
    "-bam",
    required=True,
    help="path to the bam files",
    type=click.Path(exists=True),
)
@click.option(
    "--gafpath",
    "-gaf",
    required=True,
    help="path to the gaf files",
    type=click.Path(exists=True),
)
@click.option(
    "--minlength",
    "-ml",
    default=2000,
    required=False,
    help="minimum length of circular contigs to consider",
    type=int,
)
@click.option(
    "--mincov",
    "-mcov",
    default=10,
    required=False,
    help="minimum coverage of paths to output",
    type=int,
)
@click.option(
    "--compcount",
    "-cc",
    default=500,
    required=False,
    help="maximum contig count to consider a component",
    type=int,
)
@click.option(
    "--mgfrac",
    "-mgf",
    default=0.2,
    required=False,
    help="length threshold to consider single copy marker genes",
    type=float,
)
@click.option(
    "--alignscore",
    "-as",
    default=90,
    required=False,
    help="minimum alignment score (%) for phrog annotations",
    type=float,
)
@click.option(
    "--seqidentity",
    "-si",
    default=0.3,
    required=False,
    help="minimum sequence identity for phrog annotations",
    type=float,
)
@click.option(
    "--pathlendif",
    "-pld",
    default=5000,
    required=False,
    help="path length difference threshold",
    type=int,
)
@click.option(
    "--unitigfraction",
    "-uf",
    default=0.2,
    required=False,
    help="minimum unitig fraction threshold",
    type=float,
)
@click.option(
    "--output",
    "-o",
    required=True,
    help="path to the output folder",
    type=click.Path(exists=True),
)
def main(
    graph,
    contigs,
    paths,
    hmmout,
    phrogs,
    coverage,
    bampath,
    gafpath,
    minlength,
    mincov,
    compcount,
    mgfrac,
    alignscore,
    seqidentity,
    pathlendif,
    unitigfraction,
    output,
):

    """PhaBles: Resolve bacteriophage genomes from phage bubbles in metagenomic data."""

    # Setup logger
    # ----------------------------------------------------------------------

    logger = logging.getLogger("phables 0.1")
    logger.setLevel(logging.DEBUG)
    logging.captureWarnings(True)
    formatter = logging.Formatter("%(asctime)s - %(levelname)s - %(message)s")
    consoleHeader = logging.StreamHandler()
    consoleHeader.setFormatter(formatter)
    consoleHeader.setLevel(logging.INFO)
    logger.addHandler(consoleHeader)

    # Setup output path for log file
    fileHandler = logging.FileHandler(f"{output}/phables.log")
    fileHandler.setLevel(logging.DEBUG)
    fileHandler.setFormatter(formatter)
    logger.addHandler(fileHandler)

    logger.info(
        "Welcome to PhaBles: Resolve bacteriophage genomes from phage bubbles in metagenomic data."
    )

    logger.info(f"Input arguments: ")
    logger.info(f"Assembly graph file: {graph}")
    logger.info(f"Contigs file: {contigs}")
    logger.info(f"Contig paths file: {paths}")
    logger.info(f"Contig .hmmout file: {hmmout}")
    logger.info(f"Contig phrog annotations file: {phrogs}")
    logger.info(f"Contig coverage file: {coverage}")
    logger.info(f"BAM files path: {bampath}")
    logger.info(f"GAF files path: {gafpath}")
    logger.info(f"Minimum length of contigs to consider: {minlength}")
    logger.info(f"Minimum coverage of paths to output: {mincov}")
    logger.info(f"minimum contig count to consider a component: {compcount}")
    logger.info(f"Length threshold to consider single copy marker genes: {mgfrac}")
    logger.info(f"Minimum alignment score (%) for phrog annotations: {alignscore}")
    logger.info(f"Minimum sequence identity for phrog annotations: {seqidentity}")
    logger.info(f"Path length difference threshold: {pathlendif}")
    logger.info(f"Minimum unitig fraction threshold: {unitigfraction}")
    logger.info(f"Output folder: {output}")

    start_time = time.time()

    # Get assembly graph
    # ----------------------------------------------------------------------
    (
        assembly_graph,
        edge_list,
        oriented_links,
        contig_names,
        contig_names_rev,
        graph_contigs,
        edge_depths,
        self_looped_nodes,
        edges_lengths,
    ) = edge_graph_utils.build_assembly_graph(graph)

    logger.info(
        f"Total number of vertices in the assembly graph: {len(assembly_graph.vs)}"
    )
    logger.info(
        f"Total number of links in the assembly graph: {len(assembly_graph.es)}"
    )

    # Get circular contigs
    # ----------------------------------------------------------------------
    circular = edge_utils.get_circular(paths)

    # Get contigs with bacterial single copy marker genes
    # ----------------------------------------------------------------------
    smg_contigs, contig_smgs = gene_utils.get_smg_contigs(hmmout, mgfrac)

    # Get contigs with PHROGs
    # ----------------------------------------------------------------------
    contig_phrogs = gene_utils.get_phrog_contigs(phrogs, alignscore, seqidentity)

    # Get components with viral bubbles
    # ----------------------------------------------------------------------
    pruned_vs = component_utils.get_components(
        assembly_graph,
        contig_names,
        smg_contigs,
        contig_phrogs,
        circular,
        edges_lengths,
        minlength,
    )
    logger.info(f"Total number of components found: {len(pruned_vs)}")

    # Get contig and junction pe coverages
    # ----------------------------------------------------------------------

    contig_coverages = get_edge_coverage(coverage)
    junction_pe_coverage = get_junction_pe_coverage(bampath, output)
    # junction_read_cout = get_graph_spanning_reads(gafpath, output)

    junction_read_cout = defaultdict(int)

    gaf_files = glob.glob(gafpath+"/*.gaf")

    for gaf_file in gaf_files:

        with open(gaf_file, "r") as myfile:

            for line in myfile.readlines():

                strings = line.strip().split("\t")

                # print(strings[15].split(":")[-1])

                if float(strings[15].split(":")[-1]) > 0.9:

                    if strings[5].count(">") == 2:
                        print(strings[0], strings[5])
                        edges = strings[5].split(">")[1:]
                        junction_read_cout[(edges[0], edges[1])] += 1

                    elif strings[5].count("<") == 2:
                        print(strings[0], strings[5])
                        edges = strings[5].split("<")[1:]
                        junction_read_cout[(edges[1], edges[0])] += 1

    # Resolve genomes
    # ----------------------------------------------------------------------

    resolved_edges = set()

    all_resolved_paths = []

    all_components = []

    cycle_components = set()
    resolved_components = set()
    circular_contigs = set()
    resolved_cyclic = set()

    phage_like_edges = set()

    for my_count in tqdm(pruned_vs, desc="Resolving components"):

        component_time_start = time.time()

        my_genomic_paths = []

        candidate_nodes = pruned_vs[my_count]

        pruned_graph = assembly_graph.subgraph(candidate_nodes)

        if 5627 not in candidate_nodes:
            continue

        logger.debug(f"my_count: {my_count}")

        logger.debug(f"number of contigs: {len(candidate_nodes)}")
        logger.debug(f"{candidate_nodes}")


        in_degree = []
        out_degree = []

        
        if len(candidate_nodes) == 2:

            all_self_looped = True

            for node in candidate_nodes:
                if contig_names[node] not in self_looped_nodes:
                    all_self_looped = False
            
            if all_self_looped:

                cycle_components.add(my_count)

                phage_like_edges = phage_like_edges.union(set(candidate_nodes))

                contig1 = ""
                contig2 = ""

                for edge in pruned_graph.es:
                    source_vertex_id = edge.source
                    target_vertex_id = edge.target

                    if source_vertex_id != target_vertex_id:
                        contig1 = candidate_nodes[source_vertex_id]
                        contig2 = candidate_nodes[target_vertex_id]

                if contig1 != "" and contig2 != "":

                    contig1_name = contig_names[contig1]
                    contig2_name = contig_names[contig2]

                    contig1_orientation = ""
                    contig2_orientation = ""

                    resolved_edges.add(contig1)
                    resolved_edges.add(contig2)

                    for node in oriented_links[contig1_name]:
                        for edge in oriented_links[contig1_name][node]:
                            contig1_orientation = edge[0]
                            contig2_orientation = edge[1]
                            break

                    path_string = ""

                    if contig1_orientation == "-":
                        path_string += str(graph_contigs[contig1_name].reverse_complement())
                    else:
                        path_string += str(graph_contigs[contig1_name])

                    if contig2_orientation == "-":
                        path_string += str(graph_contigs[contig2_name].reverse_complement())
                    else:
                        path_string += str(graph_contigs[contig2_name])

                    cycle_number = 1

                    genome_path = GenomePath(
                        f"phage_comp_{my_count}_cycle_{cycle_number}",
                        [f"{contig1_name}{contig1_orientation}", f"{contig2_name}{contig2_orientation}"],
                        [contig1_name, contig2_name],
                        path_string,
                        int(min(contig_coverages[contig1_name], contig_coverages[contig2_name])),
                        len(path_string),
                        (path_string.count('G') + path_string.count('C')) / len(path_string) * 100
                    )
                    my_genomic_paths.append(genome_path)
                    resolved_components.add(my_count)


        if len(candidate_nodes) > 2 and len(candidate_nodes) <= compcount:

            # Identify source/sink vertex
            source_sink_candidates = []

            source_sink = ""

            print("original candidate_nodes", candidate_nodes)


            # Create Directed Graph
            G_edge=nx.DiGraph()

            my_counter = 0

            node_indices = {}
            node_indices_rev = {}

            cycle_edges = {}

            clean_node_count = 0

            for vertex in pruned_graph.vs["id"]:

                contig_name = contig_names[vertex]

                if contig_name not in self_looped_nodes:
                    clean_node_count += 1

                for node in oriented_links[contig_name]:

                    consider_edge = False

                    if not (contig_name in self_looped_nodes and node in self_looped_nodes):
                        consider_edge = True
                    # elif contig_name in self_looped_nodes and node not in self_looped_nodes and len(str(graph_contigs[contig_name])) > 1000:
                    #     consider_edge = True
                    # elif contig_name not in self_looped_nodes and node in self_looped_nodes and len(str(graph_contigs[node])) > 1000:
                    #     consider_edge = True

                    if consider_edge:

                        cov_1 = MAX_VAL
                        cov_2 = MAX_VAL

                        if contig_name in contig_coverages:
                            cov_1 = contig_coverages[contig_name]
                        if node in contig_coverages:
                            cov_2 = contig_coverages[node]

                        min_cov = min([cov_1, cov_2])
                        min_cov = junction_read_cout[(contig_name, node)]

                        print(contig_name, node, min_cov)

                        for edge in oriented_links[contig_name][node]:
                            cycle_edges[(contig_name+edge[0], node+edge[1])] = int(min_cov)

            logger.debug(f"clean_node_count: {clean_node_count}")
            
            for cedge in cycle_edges:
                G_edge.add_edge(cedge[0], cedge[1], weight=cycle_edges[cedge])

            two_comp = sorted(nx.weakly_connected_components(G_edge), key=len)

            if len(two_comp) >= 2:
                G_edge.remove_nodes_from(list(two_comp[0]))

            print()
            print()

            for node in list(G_edge.nodes):

                contig_name = node[:-1]

                if contig_name not in self_looped_nodes and len(graph_contigs[contig_name]) > minlength:

                    bfs_successors = dict(enumerate(nx.bfs_successors(G_edge, node)))
                    print(node, "-->", bfs_successors)
                    
                    last_layer = list(bfs_successors.keys())[-1]

                    node_is_st = True

                    for item in bfs_successors[last_layer][1]:

                        if item[:-1] not in self_looped_nodes:

                            item_successors = list(G_edge.successors(item))
                            print(item, item_successors)

                            if len(item_successors) > 0 and list(G_edge.successors(item))[0] != node:
                                node_is_st = False
                                break
                            if len(item_successors) == 0:
                                node_is_st = False

                    if len(bfs_successors[last_layer][1]) == 0:
                        node_is_st = False

                    if node_is_st:
                        source_sink_candidates.append(contig_names_rev[contig_name])
                        # source_sink = contig_names_rev[contig_name]
                        # break

                    print()

            print("Identified candidate source_sinks from BFS:", source_sink_candidates)

            # longest_st = 0
            # longest_st_len = 0

            # for st in source_sink_candidates:
            #     if len(graph_contigs[contig_names[st]]) > longest_st_len:
            #         longest_st_len = len(graph_contigs[contig_names[st]])
            #         longest_st = st

            # Pick the first st candidate
            source_sink = source_sink_candidates[0]
            print("Identified source_sink from BFS:", source_sink)

            print()
            print()
            print()


            if source_sink != "":

                print("source_sink", source_sink)

                candidate_nodes.remove(source_sink)

                candidate_nodes.insert(0, source_sink)

                print("orderd candidate_nodes", candidate_nodes)


                


                # Create Directed Graph
                G=nx.DiGraph()

                for u,v,cov in G_edge.edges(data=True):

                    if u not in node_indices:
                        node_indices[u] = my_counter
                        node_indices_rev[my_counter] = u
                        my_counter += 1
                    if v not in node_indices:
                        node_indices[v] = my_counter
                        node_indices_rev[my_counter] = v
                        my_counter += 1

                    G.add_edge(node_indices[u], node_indices[v], weight=cov['weight'])

                # Get connections and degree information
                
                in_degree = []
                out_degree = []

                for node in list(G.nodes):
                    
                    if node_indices_rev[node][:-1] not in self_looped_nodes:
                        clean_indegree = len([x for x in G.predecessors(node) if node_indices_rev[x][:-1] not in self_looped_nodes])
                        in_degree.append(clean_indegree)

                        clean_outdegree = len([x for x in G.successors(node) if node_indices_rev[x][:-1] not in self_looped_nodes])
                        out_degree.append(clean_outdegree)

                degrees = in_degree + out_degree

                if len(degrees) == 0:
                    logger.debug(f"Skipping component as no clean connections were found")
                    continue



                # Get edges for flow network
                network_edges = list()

                edge_list_indices = {}

                subpaths = {}
                subpath_count = 0

                for u,v,cov in G_edge.edges(data=True):

                    print(u, contig_names_rev[u[:-1]], v, contig_names_rev[v[:-1]], cov)

                    u_name = contig_names_rev[u[:-1]]
                    v_name = contig_names_rev[v[:-1]]

                    u_index = candidate_nodes.index(u_name)
                    v_index = candidate_nodes.index(v_name)

                    edge_list_indices[u_index] = u
                    edge_list_indices[v_index] = v

                    print(u_index, v_index)

                    juction_cov = junction_pe_coverage[(u[:-1], v[:-1])]
                    # juction_cov = cov['weight'] - int(cov['weight']*0.1)

                    if v_index == 0:
                        network_edges.append((u_index, len(candidate_nodes), juction_cov, cov['weight']))
                        if junction_pe_coverage[(u[:-1], v[:-1])] != 0:
                            subpaths[subpath_count] = [u_index, len(candidate_nodes)]
                            subpath_count += 1
                        print("EDGE:", u_index, len(candidate_nodes), juction_cov, cov['weight'])
                    else:
                        network_edges.append((u_index, v_index, juction_cov, cov['weight']))
                        if junction_pe_coverage[(u[:-1], v[:-1])] != 0:
                            subpaths[subpath_count] = [u_index, v_index]
                            subpath_count += 1
                        print("EDGE:", u_index, v_index, juction_cov, cov['weight'])

                    
                print("edge_list_indices", edge_list_indices)

                G = {'Nodes':len(candidate_nodes),'list of edges': network_edges, 'subpaths': subpaths}

                listOfGraphs = {}
                listOfGraphs[0] = G

                print(listOfGraphs)

                outputfile = output+"results_gurobi_subpath.txt"
                recordfile = output+"results_gurobi_subpath_details.txt"

                solution_paths = SolveInstances(listOfGraphs, outputfile, recordfile)

                print()

                print(solution_paths)

                print()

                logger.debug(f"Number of paths found: {len(solution_paths)}")

                if len(solution_paths) != 0:
                    cycle_components.add(my_count)

                    phage_like_edges = phage_like_edges.union(set(candidate_nodes))

                    cycle_number = 1

                    for solution_path in solution_paths:
                        coverage_val = solution_paths[solution_path]["weight"]

                        if coverage_val >= mincov:

                            path_string = ""
                            total_length = 0

                            path_order = []

                            # Create graph
                            G_path = nx.Graph()
                            # Fill graph with data
                            G_path.add_edges_from(solution_paths[solution_path]["path"])

                            # Get all simple paths from node 0 to last node
                            candidate_paths = list(nx.all_simple_paths(G_path, 0, len(candidate_nodes)))

                            print("candidate_paths", candidate_paths)

                            for path_edge in candidate_paths[0]:
                                if path_edge != len(candidate_nodes):
                                    path_order.append(edge_list_indices[path_edge])

                            print("path_order", path_order)

                            for node in path_order:
                                contig_name = node[:-1]
                                if node.endswith("+"):
                                    path_string += str(graph_contigs[contig_name])
                                else:
                                    path_string += str(graph_contigs[contig_name].reverse_complement())
                                total_length += len(str(graph_contigs[contig_name]))

                            genome_path = GenomePath(
                                f"phage_comp_{my_count}_cycle_{cycle_number}",
                                [x for x in path_order],
                                [contig_names_rev[x[:-1]] for x in path_order],
                                path_string,
                                int(coverage_val),
                                total_length,
                                (path_string.count('G') + path_string.count('C')) / len(path_string) * 100
                            )
                            my_genomic_paths.append(genome_path)

                            cycle_number += 1

                    logger.debug(f"Number of paths selected: {cycle_number-1}")

                else:
                    logger.debug(f"No paths detected")
                    continue

            else:
                logger.debug(f"No source/sink node detected")
                continue

        elif len(candidate_nodes) == 1:

            contig_name = contig_names[candidate_nodes[0]]

            resolved_edges.add(candidate_nodes[0])

            path_string = str(graph_contigs[contig_name])

            cycle_number = 1

            genome_path = GenomePath(
                f"phage_comp_{my_count}_cycle_{cycle_number}",
                [contig_names[candidate_nodes[0]]],
                [candidate_nodes[0]],
                path_string,
                int(contig_coverages[contig_name]),
                len(graph_contigs[contig_name]),
                (path_string.count('G') + path_string.count('C')) / len(path_string) * 100
            )
            my_genomic_paths.append(genome_path)
            resolved_components.add(my_count)

            circular_contigs.add(my_count)

            phage_like_edges = phage_like_edges.union(set(candidate_nodes))


        visited_nodes = set()

        frac_unitigs = 1

        my_genomic_paths.sort(key=lambda x: (x.length, x.coverage), reverse=True)

        final_genomic_paths = []

        comp_resolved_edges = set()

        n_paths = 0

        if len(my_genomic_paths) > 1:

            # Get component stats
            graph_degree = assembly_graph.degree(candidate_nodes)

            path_lengths = []
            path_coverages = []

            # prev_length = my_genomic_paths[0].length

            for genomic_path in my_genomic_paths:

                logger.debug(f"{genomic_path.id}\t{genomic_path.length}\t{genomic_path.coverage}")
                logger.debug(f"{genomic_path.node_order}")
                path_lengths.append(genomic_path.length)
                path_coverages.append(genomic_path.coverage)
                final_genomic_paths.append(genomic_path)
                visited_nodes = visited_nodes.union(set(genomic_path.node_order))
                n_paths += 1

                for path_node in genomic_path.node_id_order:
                    comp_resolved_edges.add(path_node)

            frac_unitigs = len(visited_nodes)/len(candidate_nodes)

            logger.debug(f"frac_unitigs: {frac_unitigs}")

            if len(final_genomic_paths) > 1 and len(in_degree) > 0 and len(out_degree) > 0 and frac_unitigs > unitigfraction:

                genome_comp = GenomeComponent(
                    f"phage_comp_{my_count}",
                    len(candidate_nodes),
                    len(final_genomic_paths),
                    max(graph_degree),
                    max(in_degree),
                    max(out_degree),
                    sum(graph_degree) / len(graph_degree),
                    sum(in_degree) / len(in_degree),
                    sum(out_degree) / len(out_degree),
                    pruned_graph.density(loops=False),
                    max(path_lengths),
                    min(path_lengths),
                    max(path_lengths) / min(path_lengths),
                    path_lengths[path_coverages.index(max(path_coverages))],
                    path_lengths[path_coverages.index(min(path_coverages))],
                    path_lengths[path_coverages.index(max(path_coverages))]
                    / path_lengths[path_coverages.index(min(path_coverages))],
                    max(path_coverages),
                    min(path_coverages),
                    max(path_coverages) / min(path_coverages),
                    frac_unitigs
                )
                all_components.append(genome_comp)
                resolved_edges = resolved_edges.union(comp_resolved_edges)

            if len(final_genomic_paths) > 0 and frac_unitigs > unitigfraction:
                resolved_cyclic.add(my_count)
                resolved_components.add(my_count)
                all_resolved_paths += final_genomic_paths
                component_elapsed_time = time.time() - component_time_start
                logger.debug(f"Elapsed time to resolve component {my_count} with {len(candidate_nodes)} nodes: {component_elapsed_time} seconds")

        else:
            for genomic_path in my_genomic_paths:
                final_genomic_paths.append(genomic_path)
                all_resolved_paths.append(genomic_path)
                logger.debug(f"{genomic_path.id}\t{genomic_path.length}")
                resolved_components.add(my_count)

        # Write paths to file

        if frac_unitigs > unitigfraction:
            write_path(final_genomic_paths, output)
            output_genomes_path = f"{output}/resolved_phages"
            write_path_fasta(final_genomic_paths, output_genomes_path)


    logger.info(f"Total number of cyclic components found: {len(cycle_components)}")
    logger.info(f"Total number of cyclic components resolved: {len(resolved_cyclic)}")
    logger.info(f"Circular contigs identified: {len(circular_contigs)}")
    logger.info(f"Total number of cyclic components found including circular contigs: {len(cycle_components) + len(circular_contigs)}")
    logger.info(f"Total number of components resolved: {len(resolved_components)}")
    logger.info(f"Total number of genomes resolved: {len(all_resolved_paths)}")

    # Write phage-like edges
    write_edges(phage_like_edges, contig_names, graph_contigs, "phage_like_edges", output)
    logger.info(f"Resolved genomes can be found in {output}/resolved_paths.fasta")

    # Write resolved phage edges
    write_edges(resolved_edges, contig_names, graph_contigs, "resolved_edges", output)

    # Record path information
    # ----------------------------------------------------------------------

    filename = write_res_genome_info(all_resolved_paths, output)

    logger.info(
        f"Resolved genome information can be found in {output}/{filename}"
    )

    # Record component information
    # ----------------------------------------------------------------------

    filename = write_component_info(all_components, output)

    logger.info(
        f"Resolved component information can be found in {output}/{filename}"
    )

    # Get elapsed time
    # ----------------------------------------------------------------------

    # Determine elapsed time
    elapsed_time = time.time() - start_time

    # Print elapsed time for the process
    logger.info("Elapsed time: " + str(elapsed_time) + " seconds")

    # Exit program
    # ----------------------------------------------------------------------

    logger.info("Thank you for using phables!")


if __name__ == "__main__":
    main()
